

# 第8章 查找

## 1. 查找概论

![](https://img-blog.csdnimg.cn/c2893c9491cd40258f7fedb646a20401.png)

概念：

- 查找（Searching），P248
- 查找表（Search Table），P247
- 关键字（Key）/关键码，P247
- 主关键字（Primary Key）/主关键码，P247
- 次关键字（Secondary Key）/次关键码，P247
- 静态查找表（Static Search Table），P248
- 动态查找表（Dynamic Search Table），P248




## 2. 顺序表查找

概念：

- 顺序查找（Sequential Search），P249


顺序表查找算法：

```java
public static int Sequential_Search<T>(T[] record, T key)
    where T : IComparable<T>
{
    for (int i = 0; i < record.Length; i++)
    {
        if (record[i].CompareTo(key) == 0)
            return i;
    }
    return -1;
}
```





## 3. 有序表查找

![](https://img-blog.csdnimg.cn/d85d3974ec944ae19da50445ebc5bc6d.png)

概念：

- 折半查找（Binary Search），P251
- 插值查找（Interpolation Search），P253
- 斐波那契查找（Fibonacci Search），P255


折半查找代码：

```java
public static int Binary_Search<T>(T[] record, T key)
    where T : IComparable<T>
{
    int low = 0;
    int high = record.Length - 1;

    while (low <= high)
    {
        int mid = (low + high) / 2;

        if (record[mid].CompareTo(key) < 0)
            low = mid + 1;
        else if (record[mid].CompareTo(key) == 0)
            return mid;
        else
            high = mid - 1;
    }
    return -1;
}
```

插值查找代码：

```java
public static int Interpolation_Search<T>(T[] record, T key)
    where T : IComparable<T>, ISubtract<T>
{
    int low = 0;
    int high = record.Length - 1;

    if (key.Subtract(record[low]) < 0 || key.Subtract(record[high]) > 0)
        return -1;

    while (low <= high)
    {
        int mid = (low == high)
            ? low
            : low + (int)(key.Subtract(record[low]) / record[high].Subtract(record[low])
                            * (high - low));

        if (record[mid].CompareTo(key) < 0)
            low = mid + 1;
        else if (record[mid].CompareTo(key) == 0)
            return mid;
        else
            high = mid - 1;
    }
    return -1;
}
```

斐波那契查找代码：

```java
private const int MAXSIZE = 50;
private static int[] _fibonacciArray = new int[MAXSIZE];

public static int[] CalculateFibonacci()
{
    _fibonacciArray[0] = 1;
    _fibonacciArray[1] = 1;
    for (int i = 2; i < _fibonacciArray.Length; i++)
    {
        _fibonacciArray[i] = _fibonacciArray[i - 1] + _fibonacciArray[i - 2];
    }
    return _fibonacciArray;
}

public static int Fiboncci_Search<T>(T[] record, T key)
    where T : IComparable<T>
{
    int length = record.Length;
    int low = 0, high = length - 1, mid, k = 0;

    while (_fibonacciArray[k] < length)
        k++;

    T[] balance;
    if (_fibonacciArray[k] > length)
    {
        balance = new T[_fibonacciArray[k]];
        for (int i = 0; i < length; i++)
        {
            balance[i] = record[i];
        }
        for (int i = length; i < _fibonacciArray[k]; i++)
        {
            balance[i] = balance[length - 1];
        }
    }
    else
    {
        balance = record;
    }

    while (low <= high)
    {
        mid = low + _fibonacciArray[k - 1] - 1;
        if (balance[mid].CompareTo(key) > 0)
        {
            high = mid - 1;
            k -= 1;
        }
        else if (balance[mid].CompareTo(key) < 0)
        {
            low = mid + 1;
            k -= 2;
        }
        else
        {
            return mid < length ? mid : length - 1;
        }
    }
    return -1;
}
```


## 4. 线性索引查找

![](https://img-blog.csdnimg.cn/ec329b2bb01c4156a1e83466b98394a7.png)

概念：

- 索引，P257
- 线性索引，P257
- 稠密索引，P258
- 分块索引，P259
- 倒排索引，P261


稠密索引：

![](https://img-blog.csdnimg.cn/24dab47da92a420eacc0daf367248387.png)


分块索引：

![](https://img-blog.csdnimg.cn/52c2a955682148dead880f31b3fdafb5.png)

倒排索引：

![](https://img-blog.csdnimg.cn/25eb38fee4584bd59790a3576cc2a729.png)





## 5. 二叉排序树

概念：

- 二叉排序树（Binary Sort Tree），P264



二叉排序树的代码


```java
public interface ISymbolTable<TKey,TValue>
    where TKey:IComparable<TKey>
{
    void Insert(TKey key, TValue value);
    void Delete(TKey key);
    int Length { get; }
    TValue this[TKey key] { get; }
    bool Contains(TKey key);
}
```

```java
public class BinarySearchTree<TKey, TValue> : ISymbolTable<TKey, TValue>
    where TKey : IComparable<TKey>
{

    private class Node
    {
        public Node LeftChild
        {
            get;
            set;
        }
        public Node RightChild
        {
            get;
            set;
        }
        public TKey Key
        {
            get;
        }
        public TValue Value
        {
            get;
            set;
        }

        public Node(TKey key, TValue value)
        {
            Key = key;
            Value = value;
        }
    }

    private Node _root = default(Node);
    private string _orderString = string.Empty;

    public int Length
    {
        get;
        private set;
    } = 0;

    public TValue this[TKey key]
    {
        get
        {
            return GetValue(_root, key);
        }
    }

    private TValue GetValue(Node current, TKey key)
    {
        if (current == null)
        {
            return default(TValue);
        }

        int cmp = key.CompareTo(current.Key);
        if (cmp > 0)
        {
            return GetValue(current.RightChild, key);
        }
        if (cmp < 0)
        {
            return GetValue(current.LeftChild, key);
        }
        return current.Value;
    }

    public void Insert(TKey key, TValue value)
    {
        if (key == null)
        {
            throw new ArgumentNullException();
        }
        if (value == null)
        {
            throw new ArgumentNullException();
        }
        _root = Insert(_root, key, value);
    }

    private Node Insert(Node current, TKey key, TValue value)
    {
        //如果结点为空，则创建结点。
        if (current == null)
        {
            Length++;
            return new Node(key, value);
        }
        int cmp = key.CompareTo(current.Key);

        if (cmp < 0)
        {
            current.LeftChild = Insert(current.LeftChild, key, value);
        }
        else if (cmp > 0)
        {
            current.RightChild = Insert(current.RightChild, key, value);
        }
        else
        {
            current.Value = value;
        }
        return current;
    }

    public TKey Max
    {
        get
        {
            if (_root == null)
            {
                return default(TKey);
            }
            return getMax(_root);
        }
    }

    private TKey getMax(Node current)
    {
        if (current.RightChild == null)
        {
            return current.Key;
        }
        return getMax(current.RightChild);
    }

    public TKey Min
    {
        get
        {
            if (_root == null)
            {
                return default(TKey);
            }
            return getMin(_root);
        }
    }

    private TKey getMin(Node current)
    {
        if (current.LeftChild == null)
        {
            return current.Key;
        }
        return getMin(current.LeftChild);
    }

    public void DeleteMin()
    {
        if (_root == null) return;
        _root = DeleteMin(_root);
        Length--;
    }

    private Node DeleteMin(Node current)
    {
        if (current.LeftChild == null)
        {
            return current.RightChild;
        }
        current.LeftChild = DeleteMin(current.LeftChild);
        return current;
    }

    public void DeleteMax()
    {
        if (_root == null) return;
        _root = DeleteMax(_root);
        Length--;
    }

    private Node DeleteMax(Node current)
    {
        if (current.RightChild == null)
        {
            return current.LeftChild;
        }
        current.RightChild = DeleteMax(current.RightChild);
        return current;
    }

    public bool Contains(TKey key)
    {
        if (key == null)
            throw new ArgumentNullException();
        return Contains(_root, key);
    }

    private bool Contains(Node current, TKey key)
    {
        if (current == null) 
        {
            return false;
        }
        int cmp = key.CompareTo(current.Key);
        if (cmp > 0)
        {
            return Contains(current.RightChild, key);
        }
        if (cmp < 0)
        {
            return Contains(current.LeftChild, key);
        }
        return true;
    }

    public void Delete(TKey key)
    {
        if (key == null)
            throw new ArgumentNullException();

        if (Contains(key))
        {
            _root = Delete(_root, key);
            Length--;
        }
    }

    private Node Delete(Node current, TKey key)
    {
        int cmp = key.CompareTo(current.Key);

        if (cmp > 0)
        {
            current.RightChild = Delete(current.RightChild, key);
        }
        else if (cmp < 0)
        {
            current.LeftChild = Delete(current.LeftChild, key);
        }
        else
        {
            if (current.LeftChild == null)
            {
                return current.RightChild;
            }
            if (current.RightChild == null)
            {
                return current.LeftChild;
            }
            Node temp = current;
            current = GetMinNode(temp.RightChild);
            current.RightChild = DeleteMin(temp.RightChild);
            current.LeftChild = temp.LeftChild;
        }
        return current;
    }

    private Node GetMinNode(Node current)
    {
        if (current.LeftChild == null)
        {
            return current;
        }
        return GetMinNode(current.LeftChild);
    }

    private Node GetMaxNode(Node current)
    {
        if (current.RightChild == null)
        {
            return current;
        }
        return GetMaxNode(current.RightChild);
    }

    public string MidOrderTraversal()
    {
        _orderString = string.Empty;
        MidOrder(_root);
        return _orderString;
    }

    private void MidOrder(Node current)
    {
        if (current == null)
            return;
        MidOrder(current.LeftChild);
        _orderString += current.Key + " ";
        MidOrder(current.RightChild);
    }
}
```


## 6. 平衡二叉树（AVL树）

概念：

- 平衡二叉树（）



平衡二叉树代码

```java

```


## 7. 多路查找树（B树）


## 8. 散列表查找（哈希表）概述


## 9. 散列函数的构造方法


## 10. 处理散列冲突的方法


## 11. 散列表查找的实现



## 练习

### 简单题3个



### 中等题2个



### 困难题1个



