# 第7章 图
## 图的术语
#### 图的术语比较多，笔者全部列举如下，读者第一次阅读只需要大致浏览一下，后续用到了再回到这个地方查阅即可。
- 顶点：抽象的点
- 边：连接顶点的线段
- 图：图由顶点和顶点之间的边组成。要注意的是：图可以没有边，但是最少需要有一个顶点。
- 有向边：具有方向的边，
- 无向边：没有方向的边，
- 有向图：图中所有边都是有向边的图，也称为弧
- 无向图：图中所有边都是无向边的图
- 简单图：不存在顶点到具自身的边，且同一条边不重复出现则称这样的图为简单图
- 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图
- 有向完全图：在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图
- 权：边的度量单位，具体可以是距离，价格等
- 度：无向图中一个顶点所连接边的条数
- 入度：有向图独有概念，一个顶点的入度指流入该顶点边的个数
- 出度：有向图独有概念，一个顶点的入度指流出该顶点边的个数
- 网：图上的边或弧上带权则称为网
- 路径：可以通俗理解为从一个顶点到另一个顶点走过的边
- 连通：图中顶点间存在路径，两顶点存在路径则说明是连通的
- 连通图：，首先是无向图，其次图中任意两点都是连通的
- 强连通图：首先是有向图，其次图中任意两点都是连通的
- 子图：首先子图必须满足图的概念。现有两个图表示为Ga和Gb,如果Ga的所有顶点和边都可以在Gb中找到，那么Ga就是Gb的子图。注意每个图最大的子图都是本身
- 连通分量：无向图G的极大连通子图称为G的连通分量。极大连通子图的意思是：该子图是G的连通子图，如果再加入一个顶点，该子图不连通。
- 强连通分量：有向图中的极大强连通子图称做有向图的强连通分量
- 路径长度：路径中边的个数
- 生成树：无向图中连通且n顶点n-1条边叫生成树
- 有向树：有向图中顶点入度为0其余顶点入度为l的叫有向树
- 生成森林：—个有向图由若干棵有向树构成生成森林
## 图的存储结构
### 邻接矩阵
#### 用二维矩阵表示一个图的一种方式。如果矩阵元素A[i,j]等于正无穷,表示顶点i和j不连通,否则A[i,j]的值连通i和j的边的权值。这里不采用负数或者表示不连通的原因是——负权和零权是可能出现的。以下是c语言示例。

```
/*
无向图的情况
1-----2----3
|__________|
*/


int A[4][4];//c语言索引从0开始
memset(A,INT_MAX,sizeof(A));
A[1][2]=1;
A[2][1]=1;
A[2][3]=1;
A[3][2]=1;
A[1][3]=1;
A[3][1]=1;
```

```
/*
有向图的情况
1----->2---->3
*/


int A[4][4];//c语言索引从0开始
memset(A,INT_MAX,sizeof(A));
A[1][2]=1;
A[2][3]=1;
```
### 邻接表
#### 用单链表存储图的一种方式，顶点用一维数组存储。连通关系用单链表存储。示例如下。(建议学完单链表再看)

```
/*
无向图的情况
1-----2----3
|__________|
*/


struct node
{
    int val;//记录顶点
    int weight//记录权值
    node *next;//下一顶点
    //构造函数
    node():val(0),weight(0),next(nullptr)
    {

    }
    node(int v,int w):val(v),weight(w),next(nullptr)
    {

    }
    node(int v):val(v),weight(0),next(nullptr)
    {

    }
}

node* arr[4];//存储顶点
for(int i=1;i<=3;i++)
{
    arr[i]=new node(i);
}

arr[1]->next=new node(2,1);
arr[1]->next->next=node(3,1);
arr[2]->next=node(1,1);
arr[2]->next->next=node(3,1);
arr[3]->next=node(1,1);
arr[3]->next->next=node(2,1);
```

```
/*
有向图的情况
1----->2---->3
*/

struct node
{
    int val;//记录顶点
    int weight//记录权值
    node *next;//下一顶点
    //构造函数
    node():val(0),weight(0),next(nullptr)
    {

    }
    node(int v,int w):val(v),weight(w),next(nullptr)
    {

    }
    node(int v):val(v),weight(0),next(nullptr)
    {

    }
}

node* arr[4];//存储顶点
for(int i=1;i<=3;i++)
{
    arr[i]=new node(i);
}

arr[1]->next=new node(2,1);
arr[2]->next=node(3,1);


```

## 图的遍历
#### 从图中某一顶点出发访遍图中其余顶点,目使每一个顶点仅被访问一次，这-过程就叫做图的遍历

### 深度优先遍历(dfs)
#### 
