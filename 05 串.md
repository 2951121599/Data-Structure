## 串

### 1. 串的定义

串：英文称`string`，又叫字符串，是由零个或多个字符组成的有限序列。

串的长度：串中的字符数目

空串：零个字符的串，它的长度为0，可以直接用双引号"“表示

子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串；相应地包含子串的串称为主串。

```python
str1 = "123"  # 字符串，长度为3
str2 = ""  # 空串，长度为0
str3 = "hello"  # 子串
str3 = "hello world"  # 主串
```



### 2. 串的比较

比较原理：串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。

比较规则：首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较

比较操作运算符：>，>=，<，<=，==，!=

```python
print("hello" > "hel")  # True
print("hello" > "interest")  # False
print(ord("h"), ord("i"))  # 104 < 145  调用内置函数ord可以得到指定字符的ASCII码
print(ord("G") < ord("g"))  # True G：71, g:103  所以：G<g

a = b = "123"
c = "123"
print(a == b)  # True
print(a is b)  # True
print(a == c)  # True
# == 与 is 的区别：== 比较的是value；is 比较的是id
print(a is c)  # True，Pycharm做了优化，“123”在驻留池中，a，b，c存储的都是对“123”的引用
```



### 3. 串的抽象数据类型

线性表关注的是的单个元素的操作，比如增删查改。

串更多的是查找子串位置，得到指定位置子串、替换子串等操作。



### 4. 串的存储结构

字符串是数据元素类型为字符的线性表，其抽象数据类型描述与线性表相似。

串的存储结构与线性表相同，分为顺序与链式存储。

#### 4.1 串的顺序存储

串的顺序存储结构是`用一组地址连续的存储单元（一般用定长数组表示）`来存储串中的字符序列的。

缺点：长度需要遍历，并且拼接、插入、替换可能会超过数组的长度，造成数组越界。

改进：将串的存储空间在程序执行过程中动态分配，比如自由存储区（堆）。

#### 4.2 串的链式存储结构

一个结点可以存储一个或者多个字符。

缺点：不如顺序存储灵活，性能也不如顺序存储结构好。



### 5. 朴素的模式匹配算法

子串的定位操作通常称为串的模式匹配。

主串：S，索引i表示（例如：goodgoogle）

子串：T，索引j表示（例如：google）

```python
"""
朴素的字符串模式匹配算法

题目：两个字符串S（主串）和T（子串），找出该子串在主串中的位置。
     主串：S（例如：goodgoogle）
     子串：T（例如：google）
思想：对主串的每一个字符作为子串的开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开始做子串长度		 的小循环，直到匹配成功或者全部遍历完成为止。
		 时间复杂度O(m+n)
"""
def naive_string_match(S, T):
    n = len(S)
    m = len(T)

    for j in range(0, n - m + 1):
        k = 0
        for i in range(0, m):
            if S[j + i] != T[i]:
                break
            else:
                k += 1
        if k == m:
            print(j)


if __name__ == '__main__':
    S = "goodgoogle"
    T = "google"
    naive_string_match(S, T)
```



```python
"""
朴素的字符串模式匹配算法

题目：两个字符串S（主串）和T（子串），找出该子串在主串中的位置。
     主串：S（例如：goodgoogle）
     子串：T（例如：google）
思想：先用子串的第一个位置字符进行比较，匹配S中的第一位，T(2)匹配S(2)...
     如果有一位没有匹配上，终止匹配，从T中的第二位开始匹配。
"""


def naive_string_match2(S, T):
    i = 0
    _index = None
    _is_exists = False
    while i < len(S):
        if T == S[i:i + len(T)]:
            _is_exists = True
            _index = i
            break
        else:
            i = i + 1
    return _is_exists, _index


if __name__ == '__main__':
    S = "goodgoogle"
    T = "google"
    is_exists, index = naive_string_match2(S, T)
    print(is_exists, (str(index) + ":" + str(index + len(T))))
```



### 6. KMP模式匹配算法

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。

**字符串匹配**是计算机频繁进行的非常频繁的算法。其中比较经典的算法就是**BF算法**和**KMP算法**

#### 6.1 KMP算法与BF算法的不同

这两种算法都是用**模式串（p**）去匹配**主串（s）**。在BF算法，每次匹配失败的时候，都要回溯到主串下一个字符继续和模式串开头比较，在模式串比较长的时候，这种算法的**效率**就比较低。
KMP算法的改进在于引进了**next[]数组**，在匹配过程中产生**失配**时，主串不用回溯，而模式串则退回next[]数组**所指示的位置。**



#### 6.2 KMP算法的核心

KMP算法的核心，是一个被称为**部分匹配表(Partial Match Table)**的数组。我觉得理解KMP的最大障碍就是很多人在看了很多关于KMP的文章之后，仍然搞不懂PMT中的值代表了什么意思。这里我们抛开所有的枝枝蔓蔓，先来解释一下这个数据到底是什么。

对于字符串“abababca”，它的PMT如下表所示：

![img](https://picx.zhimg.com/50/v2-e905ece7e7d8be90afc62fe9595a9b0f_720w.jpg?source=1940ef5c)

就像例子中所示的，如果待匹配的模式字符串有8个字符，那么PMT就会有8个值。

我先解释一下字符串的前缀和后缀。如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。

有了这个定义，就可以说明PMT中的值的意义了。**PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**。例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。

好了，解释清楚这个表是什么之后，我们再来看如何使用这个表来加速字符串的查找，以及这样用的道理是什么。如图 1.12 所示，要在主字符串"ababababca"中查找模式字符串"abababca"。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为4。所以就可以断言，主字符串中i指针之前的 4 位一定与模式字符串的第0位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持i指针不动，然后将j指针指向模式字符串的PMT[j −1]位即可。

简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。

![img](https://pica.zhimg.com/50/v2-03a0d005badd0b8e7116d8d07947681c_720w.jpg?source=1940ef5c)

有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。

![img](https://pic2.zhimg.com/50/v2-40b4885aace7b31499da9b90b7c46ed3_720w.jpg?source=1940ef5c)

好了，讲到这里，其实KMP算法的主体就已经讲解完了。你会发现，其实KMP算法的动机是很简单的，解决的方案也很简单。只要搞明白了PMT的意义，其实整个算法都迎刃而解。

现在，我们再看一下如何编程快速求得next数组。其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。

具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。

![img](https://pic1.zhimg.com/50/v2-645f3ec49836d3c680869403e74f7934_720w.jpg?source=1940ef5c)

![img](https://pic1.zhimg.com/50/v2-06477b79eadce2d7d22b4410b0d49aba_720w.jpg?source=1940ef5c)

![img](https://pic3.zhimg.com/50/v2-8a1a205df5cad7ab2f07498484a54a89_720w.jpg?source=1940ef5c)

![img](https://pic1.zhimg.com/50/v2-f2b50c15e7744a7b358154610204cc62_720w.jpg?source=1940ef5c)

![img](https://pic2.zhimg.com/50/v2-bd42e34a9266717b63706087a81092ac_720w.jpg?source=1940ef5c)

#### 6.3 代码实现

```python
def kmp(s, p):
    """
    s为主串, p为模式串, 如果s里有p，返回开始下标
    """
    next = get_next(p)
    i = 0
    j = 0  # 分别是s和p的指针
    while i < len(s) and j < len(p):
        if j == -1 or s[i] == p[j]:  # j==-1是由于j=next[j]产生
            i += 1
            j += 1
        else:
            j = next[j]

    if j == len(p):  # j走到了末尾，说明匹配到了
        return i - j
    else:
        return -1


def get_next(p):
    """
    p为模式串
    返回next数组，即部分匹配表
    """
    next = [0] * (len(p) + 1)
    next[0] = -1  # 在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，是为了编程的方便
    i = 0
    j = -1
    while i < len(p):
        if j == -1 or p[i] == p[j]:
            i += 1
            j += 1
            next[i] = j  # 这是最大的不同：记录next[i]
        else:
            j = next[j]

    return next


if __name__ == '__main__':
    print(kmp("ababababca", "abababca"))  # 2
```



### 7. 总结

串（string）是由零个或多个字符组成的有限序列，又叫字符串。

本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。

现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该理解它的原理，以便于在碰到复杂的问题时可以更加灵活地使用。



### 8. 习题

